package com.leetcode.easy;

/**
 * #136  只出现一次的数字
 * Question：
 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 
 * 说明：
 * 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
 * 示例 1:
 * 		输入: [2,2,1]
 * 		输出: 1
 * 示例 2:
 * 		输入: [4,1,2,1,2]
 * 		输出: 4
 * Title: SingleNumber_136
 * @date 2018年6月18日
 * @author Freedom0013
 */
public class SingleNumber_136 {
	public static void main(String[] args) {
		int[] nums = {4,1,2,1,2,5,4};
		System.out.println(singleNumber(nums));
	}
	
	/**
	 * ^是异或运算符（把数据转换成二进制，然后按位进行运算）。
	 * 
	 * 运算规则：0^0 = 0， 1^0 = 1，  0^1 = 1，  1^1 = 0，运算对象相同为0，不同为1.
	 * 如：3^5 的运算过程为：
	 * (1)先将3和5转换成二进制的11和101
	 * (2)再按对应的位分别进行运算，11位数不足补零
	 *      011
	 *  ^   101
	 *  -----------
	 *  110
	 * (3)运算结果转换成10进制：6
	 * 
	 * 异或运算的三个个特点:
	 * (1) 0^0=0,   0^1=1   0与任何数异或＝任何数
	 * (2) 1^0=1,   1^1=0   1与任何数异或 =任何数取反
	 * (3) 任何数异或自己＝把自己置0
	 * 
	 * 异或运算的常见用途:
	 * (1) 使某些特定的位翻转
	 * 例如
	 * 对数10100001的第2位和第3位翻转，其他位不变，则可以将该数与00000110进行按位异或运算。
	 * 10100001^00000110 = 10100111
	 * (2) 实现两个值的交换，而不必使用临时变量。
	 * 例如交换两个整数a=10100001，b=00000110的值，可通过下列语句实现：
	 * a = a^b； 　　//a=10100111
	 * b = b^a； 　　//b=10100001
	 * a = a^b； 　　//a=00000110
	 * (3) 在汇编语言中经常用于将变量置零：
	 *  xor   a，a
	 *  (4) 快速判断两个值是否相等
	 *  判断两个整数a，b是否相等，则可通过下列语句实现：
	 *  return ((a ^ b) == 0)
	 */
	
	/**
	 * 查找只出现一次的数字
	 * @param nums 所在数组
	 * @return 数字
	 */
    public static int singleNumber(int[] nums) {
    	if(nums == null || nums.length == 0){
    		return 0;
    	}
    	int temp = 0;
    	for (int i = 0; i < nums.length; i++) {
    		//异或运算符：一个数进行两次异或运算就会变成这个数本身
			temp = temp ^ nums[i];
		}
		return temp;
    }
}
